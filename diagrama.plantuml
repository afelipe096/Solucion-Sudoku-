@startuml
!theme plain
skinparam backgroundColor #f8f9fa
skinparam activity {
    BackgroundColor #e3f2fd
    BorderColor #1976d2
    FontSize 11
}
skinparam decision {
    BackgroundColor #fff3e0
    BorderColor #f57c00
}
skinparam partition {
    BorderColor #4caf50
    BackgroundColor #f1f8e9
}

start
:ğŸ“‹ **INICIO DEL PROGRAMA**;
note right: Inicializar tablero 4x4 con nÃºmeros del 1-16

:ğŸ–¨ï¸ Imprimir tablero inicial con formato;
note left
  Mostrar:
  - Celdas vacÃ­as como "?"
  - Sumas objetivo por fila/columna
end note

:ğŸ“Š Imprimir sumas requeridas
(filas y columnas);

:âœ… Marcar nÃºmeros ya colocados
en array 'used[1..16]';
note right: Evitar duplicados desde el inicio

if (ğŸ” solve(0, 0)) then (âœ… **SOLUCIÃ“N ENCONTRADA**)
    :ğŸ‰ Imprimir "Â¡Sudoku resuelto!";
    :ğŸ–¨ï¸ Imprimir tablero completo;
    :ğŸ” Ejecutar verificaciÃ³n completa;
    
    partition "**VERIFICACIÃ“N FINAL**" {
        :Verificar sumas de todas las filas;
        :Verificar sumas de todas las columnas;
        :Verificar que nÃºmeros 1-16 estÃ©n Ãºnicos;
        
        if (âœ… Todas las verificaciones pasaron) then (SÃ­)
            :ğŸ† Imprimir "SUDOKU COMPLETAMENTE RESUELTO";
        else (No)
            :âŒ Imprimir errores encontrados;
        endif
    }
else (âŒ **NO HAY SOLUCIÃ“N**)
    :ğŸ˜ Imprimir "No se encontrÃ³ soluciÃ³n";
    :ğŸ–¨ï¸ Imprimir tablero parcial para depuraciÃ³n;
endif

:ğŸ”š **FIN DEL PROGRAMA**;
stop

' ===== FUNCIÃ“N RECURSIVA SOLVE =====
partition "**ğŸ”„ FUNCIÃ“N solve(row, col)**" {
    start
    :ğŸ“ **Entrada**: posiciÃ³n (row, col);
    
    if (ğŸ row == 4?) then (**SÃ - FIN DEL TABLERO**)
        :ğŸ¯ Â¡Tablero completo!;
        :â†©ï¸ return **true**;
        stop
    else (**NO - CONTINUAR**)
        :ğŸ§® Calcular siguiente posiciÃ³n:
        nextRow, nextCol;
        note right
          Si col == 3: nextRow = row+1, nextCol = 0
          Sino: nextRow = row, nextCol = col+1
        end note
        
        if (ğŸ”¢ board[row][col] != 0?) then (**CELDA OCUPADA**)
            :â­ï¸ Celda ya tiene nÃºmero;
            :ğŸ”„ return solve(nextRow, nextCol);
            stop
        else (**CELDA VACÃA**)
            :ğŸ² **PROBAR NÃšMEROS 1 a 16**;
            
            while (ğŸ”¢ num = 1 to 16) is (**HAY NÃšMEROS**)
                if (â“ !used[num] && canPlaceNumber(row,col,num)?) then (**NÃšMERO VÃLIDO**)
                    :âœï¸ **COLOCAR NÃšMERO**:
                    board[row][col] = num
                    used[num] = true;
                    
                    partition "**ğŸ” VALIDACIONES INTERMEDIAS**" {
                        :ğŸ isValid = true;
                        
                        if (ğŸ“ col == 3?) then (**ÃšLTIMA COLUMNA**)
                            :â• Calcular suma de fila completa;
                            if (suma == rowSum[row]?) then (SÃ­)
                                :âœ… Suma de fila correcta;
                            else (No)
                                :âŒ isValid = false;
                            endif
                        endif
                        
                        if (ğŸ“ row == 3?) then (**ÃšLTIMA FILA**)
                            :â• Calcular suma de columna completa;
                            if (suma == colSum[col]?) then (SÃ­)
                                :âœ… Suma de columna correcta;
                            else (No)
                                :âŒ isValid = false;
                            endif
                        endif
                    }
                    
                    if (âœ… isValid?) then (**VÃLIDO**)
                        :ğŸ”„ Llamada recursiva:
                        solve(nextRow, nextCol);
                        
                        if (ğŸ¯ RecursiÃ³n exitosa?) then (**SÃ**)
                            :ğŸ† Â¡SoluciÃ³n encontrada!;
                            :â†©ï¸ return **true**;
                            stop
                        endif
                    endif
                    
                    :ğŸ”™ **BACKTRACK**:
                    board[row][col] = 0
                    used[num] = false;
                    note left: Deshacer cambios y probar siguiente nÃºmero
                    
                else (**NÃšMERO INVÃLIDO**)
                    :â­ï¸ Probar siguiente nÃºmero;
                endif
            endwhile (**NO HAY MÃS NÃšMEROS**)
            
            :ğŸ’¥ NingÃºn nÃºmero funcionÃ³;
            :â†©ï¸ return **false**;
            stop
        endif
    endif
}

' ===== FUNCIÃ“N canPlaceNumber =====
partition "**ğŸ¯ FUNCIÃ“N canPlaceNumber(row, col, num)**" {
    start
    :ğŸ“ **Verificar si se puede colocar nÃºmero**;
    
    partition "**ğŸ“ VERIFICACIÃ“N DE FILA**" {
        :â• Calcular suma parcial de fila;
        :ğŸ”¢ Contar celdas vacÃ­as en fila;
        
        if (ğŸ Solo queda 1 celda vacÃ­a?) then (**ÃšLTIMA CELDA DE FILA**)
            if (suma + num == rowSum[row]?) then (SÃ­)
                :âœ… Suma exacta para fila;
            else (No)
                :âŒ return false;
                stop
            endif
        else (**HAY MÃS CELDAS**)
            if (suma + num > rowSum[row]?) then (**EXCEDE LÃMITE**)
                :âŒ return false;
                stop
            endif
        endif
    }
    
    partition "**ğŸ“ VERIFICACIÃ“N DE COLUMNA**" {
        :â• Calcular suma parcial de columna;
        :ğŸ”¢ Contar celdas vacÃ­as en columna;
        
        if (ğŸ Solo queda 1 celda vacÃ­a?) then (**ÃšLTIMA CELDA DE COLUMNA**)
            if (suma + num == colSum[col]?) then (SÃ­)
                :âœ… Suma exacta para columna;
            else (No)
                :âŒ return false;
                stop
            endif
        else (**HAY MÃS CELDAS**)
            if (suma + num > colSum[col]?) then (**EXCEDE LÃMITE**)
                :âŒ return false;
                stop
            endif
        endif
    }
    
    :âœ… NÃºmero se puede colocar;
    :â†©ï¸ return **true**;
    stop
}

@enduml